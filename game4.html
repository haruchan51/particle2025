<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>輪投げゲーム</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #004488; /* 濃い青 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
        }
        canvas {
            display: block;
            border: 5px solid #003366;
            background-color: #0077cc; /* 明るい青 */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5) inset;
        }
        #score-board {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Hiragino Kaku Gothic Pro', 'Meiryo', 'MS Gothic', sans-serif; 
            font-size: 24px;
            font-weight: bold;
            color: #333;
            z-index: 10;
            display: flex;
            gap: 30px;
            white-space: nowrap;
            opacity: 0; 
            transition: opacity 0.5s;
        }
        #throw-guide {
            /* バネのガイドライン */
            position: absolute;
            width: 0;
            height: 0;
            border-bottom: 3px solid #ffcc00; /* 太めの黄色い線でバネを表現 */
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 20;
        }
        /* 発射エリアの半透明の帯は不要になったため削除 */
    </style>
</head>
<body>

<div id="game-container">
    <div id="score-board">
        <div>スコア: <span id="score">0</span> 点</div>
        <div>残りタイム: <span id="timer">60.00</span> 秒</div>
    </div>
    <div id="throw-guide"></div> 
    <canvas id="ringTossCanvas"></canvas>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('ringTossCanvas');
        const ctx = canvas.getContext('2d');
        const guideElement = document.getElementById('throw-guide');
        const scoreBoard = document.getElementById('score-board');
        
        // ゲームの定数
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 600;
        const TOTAL_TIME = 60; 
        const RING_RADIUS = 25;
        
        // 物理演算
        const AIR_DRAG = 0.998; 
        const GRAVITY = 0.5; 
        const MAX_THROW_FORCE = 35; 
        const NUM_POSTS = 10; 

        //  固定発射位置 
        const LAUNCH_POS_X = CANVAS_WIDTH / 2;
        const LAUNCH_POS_Y = CANVAS_HEIGHT - 70;

        //  棒のサイズと配置範囲 
        const POST_HEIGHT = 70;
        const POST_WIDTH = 10;
        const POST_MIN_Y = CANVAS_HEIGHT * 0.2; // 画面上部20%
        const POST_MAX_Y = CANVAS_HEIGHT * 0.7; // 画面下部70%

        // ゲームの状態
        let score = 0;
        let timeRemaining = TOTAL_TIME;
        let gameActive = false; 
        let gameInterval;
        let rings = [];
        let posts = [];
        
        let isDragging = false;
        let launchPos = { x: LAUNCH_POS_X, y: LAUNCH_POS_Y }; // 常に固定
        let currentMousePos = { x: 0, y: 0 }; 

        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // --- ゲーム要素のクラス定義 ---
        class Post {
            constructor(x, y) {
                this.x = x; // 棒の中心X
                this.y = y; // 棒の上端Y
                this.width = POST_WIDTH;
                this.height = POST_HEIGHT; 
                this.scoreValue = 1; 
                this.color = '#ffaa00';
            }
            draw() {
                ctx.fillStyle = this.color;
                // 棒を上端Yから下に描画
                ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
            }
        }

        class Ring {
            constructor(startX, startY) {
                this.x = startX;
                this.y = startY;
                this.radius = RING_RADIUS;
                this.color = '#ff5555';
                this.vx = 0;
                this.vy = 0;
                this.isTossed = false;
                this.isScored = false;
            }
            update() {
                if (!this.isTossed || this.isScored) return;
                
                this.vx *= AIR_DRAG; 
                this.vy *= AIR_DRAG;
                this.vy += GRAVITY; 

                this.x += this.vx;
                this.y += this.vy;
                
                // 画面端の跳ね返り (左右)
                if (this.x - this.radius < 0 || this.x + this.radius > CANVAS_WIDTH) {
                    this.vx *= -0.5; 
                    this.x = Math.max(this.radius, Math.min(this.x, CANVAS_WIDTH - this.radius));
                }
                
                // 床に当たったら跳ね返り
                if (this.y + this.radius > CANVAS_HEIGHT) {
                    this.y = CANVAS_HEIGHT - this.radius;
                    this.vy *= -0.3; 
                    this.vx *= 0.6; 
                    
                    if (Math.abs(this.vy) < 0.5 && Math.abs(this.vx) < 0.5) {
                        this.isTossed = false; 
                    }
                }
            }
            draw() {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        // ------------------------------------------

        //  棒のランダム配置 
        function initializePosts() {
            posts = []; 
            for (let i = 0; i < NUM_POSTS; i++) {
                // 画面端と発射位置を避けてランダムに配置
                const x = Math.random() * (CANVAS_WIDTH - RING_RADIUS * 4) + RING_RADIUS * 2;
                const y = Math.random() * (POST_MAX_Y - POST_MIN_Y) + POST_MIN_Y; 
                posts.push(new Post(x, y));
            }
        }
        
        //  衝突判定（ランダムな浮遊棒対応） 
        function checkCollisions(ring) {
            if (ring.isScored) return;
            for (const post of posts) {
                // 1. リングの中心Xが棒の幅内にある
                const isCentered = Math.abs(ring.x - post.x) < post.width / 2;
                // 2. リングの上端が棒の上端Yよりも下にある (輪が棒を通り過ぎようとしている)
                const isPassedOver = ring.y - ring.radius < post.y;
                // 3. リングの中心Yが棒の縦の範囲内にある
                const isInsideVerticalRange = ring.y < post.y + post.height && ring.y > post.y - RING_RADIUS/2;

                if (isCentered && isPassedOver && isInsideVerticalRange) {
                    score += post.scoreValue;
                    scoreElement.textContent = score;
                    ring.isScored = true;
                    ring.color = '#33cc33';
                    ring.isTossed = false;
                    ring.vy = 0;
                    ring.vx = 0;
                    // 棒の上端に輪をスナップさせる
                    ring.y = post.y + ring.radius; 
                    return;
                }
            }
        }

        function updateGame() {
            if (!gameActive) return;
            timeRemaining -= 0.1;
            if (timeRemaining <= 0) {
                timeRemaining = 0;
                timerElement.textContent = '0.00';
                endGame();
            } else {
                timerElement.textContent = timeRemaining.toFixed(2);
            }
        }

        // --- 投擲イベント ---

        //  mousedown: 固定発射位置 
        canvas.addEventListener('mousedown', function(event) {
            if (!gameActive || rings.some(r => r.isTossed)) return; 

            // マウス位置を記録
            const rect = canvas.getBoundingClientRect();
            currentMousePos = { 
                x: event.clientX - rect.left, 
                y: event.clientY - rect.top 
            };
            
            // 固定発射位置の周りでクリックされた場合のみドラッグを開始（バネUIの誤発動防止）
            const distanceToLaunchPos = Math.sqrt(
                Math.pow(currentMousePos.x - LAUNCH_POS_X, 2) + 
                Math.pow(currentMousePos.y - LAUNCH_POS_Y, 2)
            );
            
            if (distanceToLaunchPos < 100) { // 発射位置の半径100px以内
                 isDragging = true;
            }
        });

        //  mousemove: バネUI表示 
        canvas.addEventListener('mousemove', function(event) {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            currentMousePos = { 
                x: event.clientX - rect.left, 
                y: event.clientY - rect.top 
            };
            
            updateGuideLine(launchPos, currentMousePos);
        });

        //  mouseup: 固定位置から発射 
        canvas.addEventListener('mouseup', function() {
            if (!isDragging) return;

            isDragging = false;
            guideElement.style.width = '0px'; 

            // 発射ベクトルを計算
            const dx = launchPos.x - currentMousePos.x;
            const dy = launchPos.y - currentMousePos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 5) return; 

            const force = Math.min(distance / 10, MAX_THROW_FORCE); 

            // 輪を固定発射位置から作成
            const newRing = new Ring(LAUNCH_POS_X, LAUNCH_POS_Y);
            newRing.vx = (dx / distance) * force;
            newRing.vy = (dy / distance) * force;
            newRing.isTossed = true;
            
            rings.push(newRing);

            if (!animationFrameId) {
                animate();
            }
        });
        
        // ガイドラインの更新関数 (バネUI)
        function updateGuideLine(start, end) {
            const dx = start.x - end.x;
            const dy = start.y - end.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // 描画はマウスを引いた方向 (startからend)
            const angle = Math.atan2(dy, dx); 
            
            const visualDistance = Math.min(distance, 250); 
            
            guideElement.style.left = `${end.x}px`;
            guideElement.style.top = `${end.y}px`;
            guideElement.style.width = `${visualDistance}px`;
            guideElement.style.transform = `rotate(${angle}rad)`;
        }


        // --- メインループとゲーム制御 ---
        let animationFrameId = null;

        function animate() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            //  固定発射位置のマーカー 
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(LAUNCH_POS_X, LAUNCH_POS_Y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            posts.forEach(post => post.draw());
            rings.forEach(ring => {
                ring.update();
                ring.draw();
                if (gameActive) {
                    checkCollisions(ring);
                }
            });
            
            const isAnyRingMoving = rings.some(r => r.isTossed);
            
            if (gameActive || isAnyRingMoving || timeRemaining === TOTAL_TIME) {
                animationFrameId = requestAnimationFrame(animate);
            } else if (timeRemaining === 0) {
                animationFrameId = null;
            }

            if (!gameActive) {
                drawStartScreen();
            }
        }
        
        function drawStartScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.fillStyle = 'white';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            if (timeRemaining === TOTAL_TIME) {
                ctx.fillText(`Enterキーを押してゲームスタート！`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            } else if (timeRemaining === 0) {
                ctx.fillText(`ゲーム終了！最終スコア: ${score}点`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
                ctx.font = '24px sans-serif';
                ctx.fillText(`Enterキーで再開`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            }
        }

        function startGame() {
            if (!gameActive) {
                score = 0;
                timeRemaining = TOTAL_TIME;
                gameActive = true;
                rings = []; 
                
                scoreElement.textContent = score;
                timerElement.textContent = timeRemaining.toFixed(2);
                scoreBoard.style.opacity = 1; 
                
                const oldButton = document.getElementById('restart-button');
                if (oldButton) oldButton.remove();

                clearInterval(gameInterval);
                gameInterval = setInterval(updateGame, 100); 
                
                if (!animationFrameId) {
                    animate();
                }
            }
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameInterval);
            scoreBoard.style.opacity = 0.5; 
            
            const restartButton = document.createElement('button');
            restartButton.id = 'restart-button';
            restartButton.textContent = 'もう一度プレイ (Enterで再開)';
            restartButton.style.cssText = 'position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); padding: 15px 30px; font-size: 24px; cursor: pointer;';
            restartButton.onclick = () => {
                startGame();
            };
            document.getElementById('game-container').appendChild(restartButton);
        }

        // Enterキーでのスタート/再開
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (!gameActive) {
                    startGame();
                }
            }
        });

        // 棒を初期配置し、待機画面でアニメーションを開始
        initializePosts();
        animate(); 
    });
</script>
</body>
</html>
