<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>輪投げゲーム（空気中）</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #38b43d; /* 緑の芝生や屋外をイメージ */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
        }
        canvas {
            display: block;
            border: 5px solid #287a2b;
            background-color: #5cb85c; /* 明るい地面の色 */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5) inset;
        }
        #score-board {
            /* 中央上部配置と文字化け対策 */
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Hiragino Kaku Gothic Pro', 'Meiryo', 'MS Gothic', sans-serif; 
            font-size: 24px;
            font-weight: bold;
            color: #333;
            z-index: 10;
            display: flex;
            gap: 30px;
            white-space: nowrap;
        }
        #throw-guide {
            /* 投げる方向と強さを示すガイドライン */
            position: absolute;
            width: 0;
            height: 0;
            border-bottom: 2px dashed #ffff00;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 20;
        }
        /* クリック可能エリアを示す視覚的なガイド */
        #launch-area-guide {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.1); 
            pointer-events: none; 
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="score-board">
        <div>スコア: <span id="score">0</span> 点</div>
        <div>残りタイム: <span id="timer">60.00</span> 秒</div>
    </div>
    <div id="launch-area-guide"></div> 
    <div id="throw-guide"></div> 
    <canvas id="ringTossCanvas"></canvas>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('ringTossCanvas');
        const ctx = canvas.getContext('2d');
        const guideElement = document.getElementById('throw-guide');
        
        // ゲームの定数
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 600;
        const TOTAL_TIME = 60; 
        const RING_RADIUS = 25;
        
        //  物理演算の修正点 
        const AIR_DRAG = 0.998; // 抵抗を大幅に減らし、勢いを維持
        const GRAVITY = 0.5; // 重力を強め、放物線を大きくする
        
        const MAX_THROW_FORCE = 35; // 最大投擲力を強くし、遠くまで飛ぶように調整
        const LAUNCH_AREA_HEIGHT = 200; 

        // ゲームの状態
        let score = 0;
        let timeRemaining = TOTAL_TIME;
        let gameActive = true;
        let gameInterval;
        let rings = [];
        let posts = [];
        
        let isDragging = false;
        let launchPos = { x: 0, y: 0 }; 
        let currentMousePos = { x: 0, y: 0 }; 

        // UI要素
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // --- ゲーム要素のクラス定義 ---
        class Post {
            constructor(x, height) {
                this.x = x;
                this.y = CANVAS_HEIGHT; 
                this.width = 10;
                this.height = height; 
                this.scoreValue = 1; 
                this.color = '#ffaa00'; // 黄色い棒
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height, this.width, this.height);
            }
        }

        class Ring {
            constructor(startX, startY) {
                this.x = startX;
                this.y = startY;
                this.radius = RING_RADIUS;
                this.color = '#ff5555';
                this.vx = 0;
                this.vy = 0;
                this.isTossed = false;
                this.isScored = false;
            }
            update() {
                if (!this.isTossed || this.isScored) return;
                
                //  物理演算の適用 
                this.vx *= AIR_DRAG; // わずかな空気抵抗
                this.vy *= AIR_DRAG;
                this.vy += GRAVITY; // 強めの重力で放物線を描く

                this.x += this.vx;
                this.y += this.vy;
                
                // 画面端の跳ね返り (左右)
                if (this.x - this.radius < 0 || this.x + this.radius > CANVAS_WIDTH) {
                    this.vx *= -0.5; // 減衰を大きくして勢いを失わせる
                    this.x = Math.max(this.radius, Math.min(this.x, CANVAS_WIDTH - this.radius));
                }
                
                // 床に当たったら跳ね返り
                if (this.y + this.radius > CANVAS_HEIGHT) {
                    this.y = CANVAS_HEIGHT - this.radius;
                    this.vy *= -0.3; // 床に当たると大きく減衰
                    this.vx *= 0.6; 
                    
                    // ほとんど止まったら投擲完了とみなす
                    if (Math.abs(this.vy) < 0.5 && Math.abs(this.vx) < 0.5) {
                        this.isTossed = false; 
                    }
                }
            }
            draw() {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        // ------------------------------------------

        function initializePosts() {
            posts = []; 
            const numPosts = 10; 
            const spacing = CANVAS_WIDTH / (numPosts + 1); 
            
            for (let i = 1; i <= numPosts; i++) {
                const x = spacing * i;
                const height = Math.random() * 200 + 100; 
                posts.push(new Post(x, height));
            }
        }
        
        function checkCollisions(ring) {
            if (ring.isScored) return;
            for (const post of posts) {
                const isWithinX = Math.abs(ring.x - post.x) < post.width / 2;
                const isBelowTop = ring.y + ring.radius > post.y - post.height;
                const isAboveTop = ring.y - ring.radius < post.y - post.height;
                
                if (isWithinX && isBelowTop && isAboveTop) {
                    score += post.scoreValue;
                    scoreElement.textContent = score;
                    ring.isScored = true;
                    ring.color = '#33cc33';
                    ring.isTossed = false;
                    ring.vy = 0;
                    ring.vx = 0;
                    ring.y = post.y - post.height + RING_RADIUS;
                    return;
                }
            }
        }

        function updateGame() {
            if (!gameActive) return;
            timeRemaining -= 0.1;
            if (timeRemaining <= 0) {
                timeRemaining = 0;
                timerElement.textContent = '0.00';
                endGame();
            } else {
                timerElement.textContent = timeRemaining.toFixed(2);
            }
        }

        // --- 投擲イベント ---

        const isLaunchArea = (y) => y > CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT; 

        // マウスの押下 (ドラッグ開始)
        canvas.addEventListener('mousedown', function(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            if (isLaunchArea(mouseY) && gameActive && !rings.some(r => r.isTossed)) {
                isDragging = true;
                launchPos = { x: mouseX, y: mouseY };
                currentMousePos = { x: mouseX, y: mouseY };
            }
        });

        // マウスの移動（ドラッグ中）
        canvas.addEventListener('mousemove', function(event) {
            if (!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            currentMousePos = { 
                x: event.clientX - rect.left, 
                y: event.clientY - rect.top 
            };
            
            updateGuideLine(launchPos, currentMousePos);
        });

        // マウスのリリース（発射実行）
        canvas.addEventListener('mouseup', function() {
            if (!isDragging) return;

            isDragging = false;
            guideElement.style.width = '0px'; 

            const dx = launchPos.x - currentMousePos.x;
            const dy = launchPos.y - currentMousePos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 5) { 
                return;
            }

            const force = Math.min(distance / 10, MAX_THROW_FORCE); 

            const newRing = new Ring(launchPos.x, launchPos.y);
            newRing.vx = (dx / distance) * force;
            newRing.vy = (dy / distance) * force;
            newRing.isTossed = true;
            
            rings.push(newRing);

            if (!animationFrameId) {
                animate();
            }
        });

        // ガイドラインの更新関数
        function updateGuideLine(start, end) {
            const dx = start.x - end.x;
            const dy = start.y - end.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(-dy, -dx);

            const visualForce = Math.min(distance, 250); 
            
            guideElement.style.left = `${start.x}px`;
            guideElement.style.top = `${start.y}px`;
            guideElement.style.width = `${visualForce}px`;
            guideElement.style.transform = `rotate(${angle}rad)`;
        }


        // --- メインループとゲーム制御 ---
        let animationFrameId = null;

        function animate() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            posts.forEach(post => post.draw());
            rings.forEach(ring => {
                ring.update();
                ring.draw();
                checkCollisions(ring);
            });
            const isAnyRingMoving = rings.some(r => r.isTossed);
            if (gameActive || isAnyRingMoving) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                animationFrameId = null; 
            }
        }
        
        function startGame() {
            score = 0;
            timeRemaining = TOTAL_TIME;
            gameActive = true;
            rings = [];
            
            scoreElement.textContent = score;
            timerElement.textContent = timeRemaining.toFixed(2);
            
            const oldButton = document.getElementById('restart-button');
            if (oldButton) oldButton.remove();

            initializePosts();
            clearInterval(gameInterval);
            gameInterval = setInterval(updateGame, 100); 
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameInterval);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.fillStyle = 'white';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`時間切れ！最終スコア: ${score}点`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            
            const restartButton = document.createElement('button');
            restartButton.id = 'restart-button';
            restartButton.textContent = 'もう一度プレイ';
            restartButton.style.cssText = 'position: absolute; top: 55%; left: 50%; transform: translate(-50%, -50%); padding: 15px 30px; font-size: 24px; cursor: pointer;';
            restartButton.onclick = () => {
                startGame();
            };
            document.getElementById('game-container').appendChild(restartButton);
        }

        // ゲーム開始
        startGame();
    });
</script>
</body>
</html>
