<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚†ã‚‰ã‚†ã‚‰ã‚­ãƒ£ãƒ³ãƒ‡ã‚£ã‚¿ãƒ¯ãƒ¼</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* å¯æ„›ã‚‰ã—ã„ç©ºã®ã‚ˆã†ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
            background: linear-gradient(to bottom, #87CEEB, #ADD8E6); 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', sans-serif;
        }
        #game-container {
            position: relative;
        }
        canvas {
            display: block;
            border: 5px solid #6A5ACD;
            /* Canvasã®èƒŒæ™¯ã‚‚æ˜ã‚‹ã„ç©ºè‰² */
            background: linear-gradient(to bottom, #B0E0E6, #E0FFFF); 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2) inset;
        }
        #score-board {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #FF69B4;
            z-index: 10;
            display: flex;
            gap: 40px;
            white-space: nowrap;
            opacity: 0; 
            transition: opacity 0.5s;
            border: 2px dashed #FFD700;
        }
        #throw-guide {
            position: absolute;
            width: 0;
            height: 0;
            border-bottom: 4px dotted #FFC0CB;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 20;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="score-board">
        <div>ã‚¹ã‚³ã‚¢: <span id="score">0</span> ç‚¹</div>
        <div>æ®‹ã‚Šã‚¿ã‚¤ãƒ : <span id="timer">60.00</span> ç§’</div>
    </div>
    <div id="throw-guide"></div> 
    <canvas id="ringTossCanvas"></canvas>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('ringTossCanvas');
        const ctx = canvas.getContext('2d');
        const guideElement = document.getElementById('throw-guide');
        const scoreBoard = document.getElementById('score-board');
        
        // --- ã‚²ãƒ¼ãƒ ã®å®šæ•° ---
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 600;
        const TOTAL_TIME = 60; 
        const RING_RADIUS = 25;
        
        // ç‰©ç†æ¼”ç®—
        const AIR_DRAG = 0.998; 
        const GRAVITY = 0.5; 
        const MAX_THROW_FORCE = 50; 
        const NUM_POSTS = 10; 

        // ç™ºå°„ä½ç½® (ç”»é¢ä¸Šéƒ¨ä¸­å¤®)
        const LAUNCH_POS_X = CANVAS_WIDTH / 2;
        const LAUNCH_POS_Y = 100; 

        // æ£’ã®ã‚µã‚¤ã‚ºã¨é…ç½®ç¯„å›² 
        const POST_WIDTH = 15; 
        const POST_HEIGHT_MIN = 80;
        const POST_HEIGHT_MAX = 150;
        const POST_MIN_Y = CANVAS_HEIGHT * 0.3; 
        const POST_MAX_Y = CANVAS_HEIGHT * 0.9; 
        
        // ğŸš¨ æ–°æ©Ÿèƒ½: æ£’ã®æºã‚Œè¨­å®š ğŸš¨
        const WOBBLE_RANGE = 0.15; // æºã‚Œã®è§’åº¦ (ãƒ©ã‚¸ã‚¢ãƒ³)
        const WOBBLE_SPEED = 0.005; // æºã‚Œã®é€Ÿã•

        // --- ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ ---
        let score = 0;
        let timeRemaining = TOTAL_TIME;
        let gameActive = false; 
        let gameInterval;
        let rings = [];
        let posts = [];
        
        let isDragging = false;
        let launchPos = { x: LAUNCH_POS_X, y: LAUNCH_POS_Y }; 
        let currentMousePos = { x: 0, y: 0 }; 

        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // --- ã‚²ãƒ¼ãƒ è¦ç´ ã®ã‚¯ãƒ©ã‚¹å®šç¾© ---
        class Post {
            constructor(x, y, height, wobbleOffset) { 
                this.x = x; 
                this.y = y; 
                this.width = POST_WIDTH;
                this.height = height;
                this.scoreValue = 1; 
                this.color = this.getRandomCandyColor();
                // ğŸš¨ æ–°ã—ã„æºã‚Œãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ ğŸš¨
                this.wobbleTime = wobbleOffset; 
                this.angle = 0; // ç¾åœ¨ã®è§’åº¦
            }

            getRandomCandyColor() {
                const colors = ['#FFB6C1', '#FFD700', '#87CEEB', '#98FB98', '#FFDAB9', '#BA55D3', '#FF6347'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            // ğŸš¨ æ£’ã®æ›´æ–°: æºã‚Œã®è¨ˆç®— ğŸš¨
            update() {
                this.wobbleTime += WOBBLE_SPEED;
                this.angle = Math.sin(this.wobbleTime) * WOBBLE_RANGE;
            }

            draw() {
                // å›è»¢ã®ä¸­å¿ƒï¼ˆæ£’ã®ä¸‹ç«¯ï¼‰ã‚’è¨­å®š
                const pivotX = this.x;
                const pivotY = this.y + this.height;

                ctx.save();
                ctx.translate(pivotX, pivotY);
                ctx.rotate(this.angle);
                
                // æ£’æœ¬ä½“ï¼ˆå›è»¢ã®ä¸­å¿ƒã¯æ–°ã—ã„åŸç‚¹(0, 0)ã‹ã‚‰ä¸Šã«ãšã‚‰ã—ã¦æç”»ï¼‰
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height, this.width, this.height);

                // ä¸Šä¸‹ã«ãƒªãƒœãƒ³/ãƒ•ãƒªãƒ«ã‚’è¿½åŠ  (å›è»¢ã¨ä¸¦é€²ã‚’è€ƒæ…®)
                ctx.fillStyle = 'white';
                const ribbonHeight = 10;
                ctx.fillRect(-this.width / 2 - 5, -this.height - ribbonHeight / 2, this.width + 10, ribbonHeight);
                ctx.fillRect(-this.width / 2 - 5, -ribbonHeight / 2, this.width + 10, ribbonHeight);

                // ç´°ã‹ã„ç¸æ¨¡æ§˜ã‚’è¿½åŠ 
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; 
                for (let i = 0; i < this.height; i += 10) {
                    ctx.fillRect(-this.width / 2, -this.height + i, this.width, 5);
                }

                ctx.restore();
            }
        }

        class Ring {
            constructor(startX, startY) {
                this.x = startX;
                this.y = startY;
                this.radius = RING_RADIUS;
                this.color = this.getRandomRingColor();
                this.vx = 0;
                this.vy = 0;
                this.isTossed = false;
                this.isScored = false;
            }

            getRandomRingColor() {
                const colors = ['#FF69B4', '#FFFF00', '#00BFFF', '#ADFF2F', '#FF8C00', '#EE82EE'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                if (!this.isTossed || this.isScored) return;
                
                this.vx *= AIR_DRAG; 
                this.vy *= AIR_DRAG;
                this.vy += GRAVITY; 

                this.x += this.vx;
                this.y += this.vy;
                
                // ç”»é¢ç«¯ã®è·³ã­è¿”ã‚Š (å·¦å³)
                if (this.x - this.radius < 0 || this.x + this.radius > CANVAS_WIDTH) {
                    this.vx *= -0.5; 
                    this.x = Math.max(this.radius, Math.min(this.x, CANVAS_WIDTH - this.radius));
                }
                
                // åºŠã«å½“ãŸã£ãŸã‚‰è·³ã­è¿”ã‚Š
                if (this.y + this.radius > CANVAS_HEIGHT) {
                    this.y = CANVAS_HEIGHT - this.radius;
                    this.vy *= -0.3; 
                    this.vx *= 0.6; 
                    if (Math.abs(this.vy) < 0.5 && Math.abs(this.vx) < 0.5) {
                        this.isTossed = false; 
                    }
                }
                
                // å¤©äº•ã«å½“ãŸã£ãŸã‚‰è·³ã­è¿”ã‚Š
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -0.3;
                    this.vx *= 0.6; 
                }
            }
            
            draw() {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.save();
                ctx.clip(); 
                ctx.beginPath();
                ctx.arc(this.x + this.radius * 0.4, this.y - this.radius * 0.4, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
                ctx.restore();
            }
        }
        // ------------------------------------------

        // æ£’ã®ãƒ©ãƒ³ãƒ€ãƒ é…ç½® (æºã‚Œã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ )
        function initializePosts() {
            posts = []; 
            for (let i = 0; i < NUM_POSTS; i++) {
                const x = Math.random() * (CANVAS_WIDTH - RING_RADIUS * 4) + RING_RADIUS * 2;
                const y = Math.random() * (POST_MAX_Y - POST_MIN_Y) + POST_MIN_Y; 
                const height = Math.random() * (POST_HEIGHT_MAX - POST_HEIGHT_MIN) + POST_HEIGHT_MIN;
                // ğŸš¨ æºã‚Œã®åˆæœŸä½ç›¸ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã« ğŸš¨
                const wobbleOffset = Math.random() * Math.PI * 2; 
                posts.push(new Post(x, y, height, wobbleOffset));
            }
        }
        
        // ğŸš¨ è¡çªåˆ¤å®š (æºã‚Œã¦ã„ã‚‹æ£’ã«å¯¾å¿œ) ğŸš¨
        function checkCollisions(ring) {
            if (ring.isScored) return;
            for (const post of posts) {
                // è¼ªã®ä¸­å¿ƒã‹ã‚‰æ£’ã®ä¸Šç«¯ã¾ã§ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const dx = ring.x - post.x;
                const dy = ring.y - (post.y + post.height); 
                
                // è¼ªã®ä¸­å¿ƒåº§æ¨™ã‚’æ£’ã®å›è»¢åº§æ¨™ç³»ã«å¤‰æ›
                const cosA = Math.cos(-post.angle);
                const sinA = Math.sin(-post.angle);
                
                const rotatedX = dx * cosA - dy * sinA;
                const rotatedY = dx * sinA + dy * cosA;

                // å›è»¢å¾Œã®åº§æ¨™ã§è¡çªåˆ¤å®š
                const topY = -post.height;
                const bottomY = 0;
                const leftX = -post.width / 2;
                const rightX = post.width / 2;

                // è¼ªã®ä¸­å¿ƒãŒå›è»¢å¾Œã®æ£’ã®Xç¯„å›²å†…ã«ã‚ã‚Šã€ã‹ã¤Yç¯„å›²å†…ã«ã„ã‚‹ã‹
                const isCentered = Math.abs(rotatedX) < post.width / 2;
                const isBelowTop = rotatedY < bottomY; // è¼ªã®ä¸­å¿ƒãŒæ£’ã®å›è»¢ä¸­å¿ƒã‚ˆã‚Šä¸Š
                const isAboveBottom = rotatedY > topY; // è¼ªã®ä¸­å¿ƒãŒæ£’ã®å…ˆç«¯ã‚ˆã‚Šä¸‹

                // è¼ªãŒæ£’ã®è¿‘ãã‚’é€šã‚‹ã‹ï¼ˆè¼ªæŠ•ã’ã®åˆ¤å®šã¯ç°¡ç•¥åŒ–ã—ã¾ã™ï¼‰
                if (isCentered && isBelowTop && isAboveBottom) {
                    // ã“ã“ã§ã•ã‚‰ã«æ­£ç¢ºãªãƒªãƒ³ã‚°åˆ¤å®šã‚’è¡Œã†ã¹ãã ãŒã€ç°¡å˜ã®ãŸã‚ã«æ£’ã®ä¸Šç«¯Yåº§æ¨™ã‚’ä½¿ã†
                    // è¼ªãŒæ£’ã®ä¸Šç«¯ã‚’ã¾ãŸã„ã ã‹ï¼ˆå›è»¢ã‚’è€ƒæ…®ã—ãŸæ£’ã®ä¸Šç«¯ã®Yåº§æ¨™ï¼‰
                    const postTopY = post.y + post.height + (post.height * Math.cos(post.angle) - post.height); 

                    // è¼ªãŒä¸Šã‹ã‚‰ä¸‹ã¸ç§»å‹•ã—ã¦ã„ã‚‹ã‹
                    if (ring.vy > 0 && ring.y - ring.radius < postTopY) {
                         // ã‚¹ã‚³ã‚¢åˆ¤å®šå¾Œã®å‡¦ç†
                        score += post.scoreValue;
                        scoreElement.textContent = score;
                        ring.isScored = true;
                        ring.color = '#90EE90';
                        ring.isTossed = false;
                        ring.vy = 0;
                        ring.vx = 0;
                        
                        // è¼ªã‚’æ£’ã«ã‚¹ãƒŠãƒƒãƒ—ã•ã›ã‚‹ (å›è»¢è§’åº¦ã¯ç„¡è¦–ã—ã¦å‚ç›´ã«ã‚¹ãƒŠãƒƒãƒ—)
                        ring.x = post.x;
                        ring.y = post.y + post.height - post.height / 2; 
                        
                        // è¼ªã‚’æ£’ã®æºã‚Œã«åˆã‚ã›ã¦å‹•ã‹ã™
                        ring.update = function() {
                            if (this.isScored) {
                                // è¼ªã‚’æ£’ã¨ä¸€ç·’ã«æºã‚‰ã™
                                this.x = post.x + post.height/2 * Math.sin(post.angle); // Xè»¸ã®æºã‚Œ
                                this.y = post.y + post.height - this.radius;
                            }
                        }

                        return;
                    }
                }
            }
        }

        function updateGame() {
            if (!gameActive) return;
            timeRemaining -= 0.1;
            if (timeRemaining <= 0) {
                timeRemaining = 0;
                timerElement.textContent = '0.00';
                endGame();
            } else {
                timerElement.textContent = timeRemaining.toFixed(2);
            }
        }

        // --- æŠ•æ“²ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¤‰æ›´ãªã—ï¼‰ ---
        canvas.addEventListener('mousedown', function(event) {
            if (!gameActive || rings.some(r => r.isTossed)) return; 
            const rect = canvas.getBoundingClientRect();
            currentMousePos = { x: event.clientX - rect.left, y: event.clientY - rect.top };
            const distanceToLaunchPos = Math.sqrt(
                Math.pow(currentMousePos.x - LAUNCH_POS_X, 2) + 
                Math.pow(currentMousePos.y - LAUNCH_POS_Y, 2)
            );
            if (distanceToLaunchPos < 100) { isDragging = true; }
        });

        canvas.addEventListener('mousemove', function(event) {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            currentMousePos = { x: event.clientX - rect.left, y: event.clientY - rect.top };
            updateGuideLine(launchPos, currentMousePos);
        });

        canvas.addEventListener('mouseup', function() {
            if (!isDragging) return;
            isDragging = false;
            guideElement.style.width = '0px'; 
            const dx = launchPos.x - currentMousePos.x;
            const dy = launchPos.y - currentMousePos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 5) return; 
            const force = Math.min(distance / 10, MAX_THROW_FORCE); 
            const newRing = new Ring(LAUNCH_POS_X, LAUNCH_POS_Y);
            newRing.vx = (dx / distance) * force;
            newRing.vy = (dy / distance) * force;
            newRing.isTossed = true;
            rings.push(newRing);
            if (!animationFrameId) { animate(); }
        });
        
        function updateGuideLine(start, end) {
            const dx = start.x - end.x;
            const dy = start.y - end.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx); 
            const visualDistance = Math.min(distance, 250); 
            guideElement.style.left = `${end.x}px`;
            guideElement.style.top = `${end.y}px`;
            guideElement.style.width = `${visualDistance}px`;
            guideElement.style.transform = `rotate(${angle}rad)`;
        }


        // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã¨ã‚²ãƒ¼ãƒ åˆ¶å¾¡ ---
        let animationFrameId = null;

        function animate() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // å›ºå®šç™ºå°„ä½ç½®ã®ãƒãƒ¼ã‚«ãƒ¼
            drawHeart(ctx, LAUNCH_POS_X, LAUNCH_POS_Y, 15, '#FF69B4');
            
            // ğŸš¨ ä¿®æ­£ç‚¹: æ£’ã®æºã‚Œã‚’æ›´æ–° ğŸš¨
            posts.forEach(post => {
                if (gameActive) post.update();
                post.draw();
            });
            
            rings.forEach(ring => {
                ring.update();
                ring.draw();
                if (gameActive) {
                    checkCollisions(ring);
                }
            });
            
            const isAnyRingMoving = rings.some(r => r.isTossed);
            
            if (gameActive || isAnyRingMoving || timeRemaining === TOTAL_TIME) {
                animationFrameId = requestAnimationFrame(animate);
            } else if (timeRemaining === 0) {
                animationFrameId = null;
            }

            if (!gameActive) {
                drawStartScreen();
            }
        }
        
        // ãƒãƒ¼ãƒˆã‚’æç”»ã™ã‚‹é–¢æ•°
        function drawHeart(ctx, x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y + size / 4);
            ctx.quadraticCurveTo(x + size / 2, y - size / 2, x + size, y - size / 4);
            ctx.quadraticCurveTo(x + size, y + size / 2, x, y + size);
            ctx.quadraticCurveTo(x - size, y + size / 2, x - size, y - size / 4);
            ctx.quadraticCurveTo(x - size / 2, y - size / 2, x, y + size / 4);
            ctx.closePath();
            ctx.fill();
        }

        function drawStartScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.fillStyle = 'white';
            ctx.font = '50px "Comic Sans MS", "Arial Rounded MT Bold", sans-serif'; 
            ctx.textAlign = 'center';
            if (timeRemaining === TOTAL_TIME) {
                ctx.fillText(`âœ¨ ã‚†ã‚‰ã‚†ã‚‰ã‚­ãƒ£ãƒ³ãƒ‡ã‚£ã‚¿ãƒ¯ãƒ¼ âœ¨`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);
                ctx.font = '30px "Comic Sans MS", "Arial Rounded MT Bold", sans-serif';
                ctx.fillText(`Enterã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼ (æ£’ãŒæºã‚Œã‚‹ã‚ˆ!)`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            } else if (timeRemaining === 0) {
                ctx.fillText(`ã‚²ãƒ¼ãƒ çµ‚äº†ï¼`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 60);
                ctx.fillText(`æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score}ç‚¹`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                ctx.font = '30px "Comic Sans MS", "Arial Rounded MT Bold", sans-serif';
                ctx.fillText(`ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤ï¼ŸEnterã‚­ãƒ¼ã§å†é–‹ï¼`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
            }
        }

        function startGame() {
            if (!gameActive) {
                score = 0;
                timeRemaining = TOTAL_TIME;
                gameActive = true;
                rings = []; 
                initializePosts(); // æ–°ã—ã„æºã‚Œã®æ£’ã‚’ãƒªã‚»ãƒƒãƒˆ
                
                scoreElement.textContent = score;
                timerElement.textContent = timeRemaining.toFixed(2);
                scoreBoard.style.opacity = 1; 
                
                clearInterval(gameInterval);
                gameInterval = setInterval(updateGame, 100); 
                
                if (!animationFrameId) {
                    animate();
                }
            }
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameInterval);
            scoreBoard.style.opacity = 0.5; 
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (!gameActive) {
                    startGame();
                }
            }
        });

        initializePosts();
        animate(); 
    });
</script>
</body>
</html>
